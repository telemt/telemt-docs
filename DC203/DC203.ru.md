# Поведение C-референса при запросах клиента с `dc=203`

Данный разбор основан непосредственно на реальном control flow и структурах данных официальной C-реализации MTProxy. 
Ниже описано именно фактическое поведение на уровне транспорта и маршрутизации, а не абстрактная модель протокола MTProto.

---

## 1. Извлечение целевого DC из инициализационного заголовка

В режиме расширенной обфускации (`extmode2`) каждая клиентская TCP-сессия начинается с передачи 64-байтного блока (`random_header`), который после расшифровки содержит служебные параметры соединения.

Ключевые поля находятся в конце этого буфера:

- Смещение `+56`: 32-битное поле `tag`, используемое для определения режима и проверки корректности заголовка.
- Смещение `+60`: 16-битное целое (`short`), содержащее идентификатор целевого дата-центра (DC).

Это значение сразу сохраняется во внутренней структуре соединения:

```

TCP_RPC_DATA(connection)->extra_int4 = target_dc;

```

Важно, что это присваивание выполняется ровно один раз на этапе установления соединения и больше не изменяется в течение всей жизни TCP-сессии. В коде отсутствует какой-либо механизм, который мог бы позднее изменить этот параметр на основе содержимого MTProto-payload.

В рассматриваемом случае это означает:

```

TCP_RPC_DATA(c)->extra_int4 == 203

```

и именно это значение становится единственным источником истины для всей дальнейшей маршрутизации.

---

## 2. Использование `extra_int4` в механизме маршрутизации

После установления соединения каждый входящий MTProto-фрейм проходит через стандартный путь обработки:

```

forward_mtproto_packet(...)
→ choose_proxy_target(TCP_RPC_DATA(C)->extra_int4)

```

Поле `extra_int4` используется как основной ключ для выбора backend-кластера.

Функция `choose_proxy_target()` реализует следующий алгоритм:

1. Попытка найти кластер через:

```

mf_cluster_lookup(CurConf, target_dc, force=1)

```

2. Если кластер с ID 203 существует:
→ он выбирается напрямую.

3. Если такого кластера нет:
→ немедленно используется глобально определённый `default_cluster`.

Параметр `force=1` принципиален — он гарантирует fallback на default-cluster вместо немедленного отказа.

После выбора кластера выбирается конкретное backend-соединение:

- случайным образом выбирается кандидат,
- проверяется, что соединение активно (`connected`) и не находится в состоянии закрытия,
- при необходимости попытка повторяется до пяти раз.

Это предотвращает использование неработающих или завершающихся соединений.

---

## 3. Полностью прозрачная пересылка без анализа MTProto-payload

Архитектурно важно, что MTProxy не выполняет семантический анализ MTProto-payload.

В частности, proxy не выполняет:

- парсинг TL-объектов,
- анализ RPC-методов,
- разбор message containers,
- изменение целевого DC на основе содержимого.

Proxy работает строго на транспортном уровне и рассматривает payload как непрозрачный бинарный поток.

Обработка ограничивается следующими шагами:

1. Снятие транспортной обёртки,
2. Привязка пакета к существующей outbound RPC-сессии,
3. Упаковка в внутренний контейнер `RPC_PROXY_REQ`,
4. Пересылка по соответствующему backend TCP-соединению.

Содержимое payload передаётся без каких-либо изменений, бит-в-бит.

---

## 4. Поведение при отсутствии доступного backend-маршрута

Если подходящее backend-соединение не найдено или все соединения кластера недоступны, активируется штатный механизм отказа.

При этом происходит следующее:

- запрос отбрасывается,
- увеличивается глобальный счётчик `dropped_queries`,
- соединение помечается флагом:

```

RPC_F_DROPPED

```

Этот флаг означает, что дальнейшая обработка запросов для данного соединения невозможна.

На практике это приводит к:

- игнорированию последующих пакетов,
- последующему закрытию соединения по timeout или через явное завершение.

Важно: proxy не выполняет автоматическую смену DC или повторную маршрутизацию на другие DC. Используется строго тот DC, который был указан при инициализации.

---

## 5. Обратная передача ответов от backend к клиенту

Ответы от backend-сервера обрабатываются через стандартный RPC-механизм proxy:

```

RPC_PROXY_ANS → поиск по out_conn_id

```

Proxy поддерживает внутреннюю таблицу соответствия между backend-соединениями и клиентскими соединениями.

Если соответствие найдено:

```

client_send_message(...)

```

пересылает ответ клиенту без изменений.

Если соответствие отсутствует (например, клиент уже отключился):

```

RPC_CLOSE_CONN

```

отправляется backend-серверу для корректного освобождения ресурсов.

Это предотвращает зависание неиспользуемых backend-соединений.

---

## 6. Управление маршрутизацией DC 203 через конфигурацию

Маршрутизация полностью определяется конфигурацией proxy.

Пример:

```

proxy_for 203 149.154.x.x:443;

```

создаёт кластер с:

```

cluster_id = 203

```

и назначает ему указанный backend-сервер.

Также может быть определён fallback-кластер:

```

default 2;

```

Он используется, если конкретный кластер для указанного DC отсутствует.

Если директива `proxy_for 203` не задана, весь трафик с `dc=203` автоматически направляется в default-cluster.

---

## 7. Итоговое поведение системы для `dc=203`

Для клиентского соединения с `dc=203` выполняются следующие условия:

- DC извлекается один раз из инициализационного obfuscation-заголовка.
- Это значение сохраняется во внутреннем состоянии соединения.
- Весь трафик данной TCP-сессии маршрутизируется исключительно на основе этого значения.
- Если существует кластер с ID 203 — используется он.
- Если нет — используется default-cluster.
- Содержимое MTProto-payload не влияет на выбор маршрута.
- Proxy функционирует исключительно как stateful транспортный ретранслятор без анализа протокола.

Таким образом, целевой DC полностью определяется и фиксируется на этапе установления соединения и остаётся неизменным до его завершения.
