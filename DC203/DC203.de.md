# Tatsächliches Laufzeitverhalten der C-Implementirung bei Client-Anfragen mit `dc=203`

Diese Auswertung basiert unmittelbar auf dem Kontrollfluss und den Datenstrukturen der offiziellen C-Referenzimplementierung. Es handelt sich nicht um eine abstrahierte Beschreibung des MTProto-Protokolls, sondern um eine konkrete Analyse des effektiven Verhaltens auf Transport- und Routingebene.

---

## 1. Extraktion des Ziel-DC aus dem Initialisierungsheader

Im sogenannten „extended obfuscation mode“ (`extmode2`) beginnt jede Client-Verbindung mit einem 64-Byte-Initialisierungsblock (`random_header`), der nach erfolgreicher Entschlüsselung mehrere Steuerparameter enthält.

Relevant sind hier zwei Felder im hinteren Abschnitt des Puffers:

- Offset `+56`: 32-Bit-`tag`, dient der Moduserkennung und Integritätsprüfung.
- Offset `+60`: 16-Bit-Integer (`short`), welcher die gewünschte Ziel-DC-ID repräsentiert.

Dieser Wert wird unmittelbar in die Verbindungsstruktur übernommen:

```

TCP_RPC_DATA(connection)->extra_int4 = target_dc;

```

Entscheidend ist hierbei: Diese Zuordnung erfolgt einmalig während der Initialisierung und bleibt für die gesamte Lebensdauer dieser TCP-Session unverändert. Es existiert kein Mechanismus, der diesen Wert später dynamisch anhand von Payload-Inhalten überschreibt.

Im konkreten Fall bedeutet dies:

```

TCP_RPC_DATA(c)->extra_int4 == 203

```

ist die alleinige, verbindliche Routingreferenz für diese Session.

---

## 2. Rolle von `extra_int4` im Weiterleitungsmechanismus

Sobald die Verbindung etabliert ist, durchläuft jedes eingehende MTProto-Frame denselben Forwarding-Pfad:

```

forward_mtproto_packet(...)
→ choose_proxy_target(TCP_RPC_DATA(C)->extra_int4)

```

Hier fungiert `extra_int4` als primärer Schlüssel zur Auswahl eines Zielclusters.

Die Funktion `choose_proxy_target()` implementiert dabei folgenden Entscheidungsalgorithmus:

1. Lookup des Clusters über:

```

mf_cluster_lookup(CurConf, target_dc, force=1)

```

2. Falls ein Cluster mit ID 203 existiert:
→ direkte Verwendung dieses Clusters.

3. Falls kein solcher Cluster existiert:
→ sofortiger Fallback auf den global definierten `default_cluster`.

Der Parameter `force=1` ist hierbei entscheidend: Er verhindert ein sofortiges Scheitern und erzwingt stattdessen die Nutzung eines Fallback-Clusters.

Anschließend erfolgt die konkrete Auswahl einer Zielverbindung innerhalb des Clusters:

- zufällige Auswahl eines Kandidaten
- Validierung des Verbindungszustands (`connected`, nicht `closing`)
- optionales Wiederholen dieses Prozesses bis zu fünfmal

Dies verhindert, dass temporär defekte oder im Shutdown befindliche Verbindungen verwendet werden.

---

## 3. Vollständig transparente Weiterleitung ohne Payload-Interpretation

Ein zentraler architektonischer Punkt: MTProxy analysiert die eigentliche MTProto-Payload nicht semantisch.

Insbesondere findet **keine** der folgenden Operationen statt:

- kein Parsing von TL-Objekten
- keine Analyse von RPC-Methoden
- keine Inspektion von Message-Containern
- keine dynamische Neuberechnung der Ziel-DC

Der Proxy arbeitet strikt auf Transportebene und behandelt die Nutzlast als opaque binary blob.

Die Verarbeitung reduziert sich auf:

1. Entfernen der äußeren Transport-Hülle
2. Zuordnung zur bestehenden Outbound-RPC-Session
3. Verpackung in ein internes RPC_PROXY_REQ-Frame
4. Weiterleitung über die bereits etablierte Backend-TCP-Verbindung

Der Inhalt selbst bleibt bitgenau unverändert.

---

## 4. Verhalten bei fehlender oder nicht verfügbarer Zielverbindung

Wenn kein funktionsfähiges Backend-Target gefunden werden kann, tritt ein klar definierter Fehlerpfad in Kraft.

Intern passiert Folgendes:

- Der Request wird verworfen
- Der globale Statistikzähler `dropped_queries` wird inkrementiert
- Die Client-Verbindung erhält das Statusflag:

```

RPC_F_DROPPED

```

Dieses Flag signalisiert einen permanenten Routingfehler.

Im weiteren Verlauf führt dies typischerweise zu:

- Ignorieren weiterer Pakete dieser Session
- eventualem Verbindungsabbruch durch Timeout oder expliziten Close

Wichtig: Es erfolgt kein automatischer Retry mit alternativen DC-IDs. Der Proxy respektiert strikt den ursprünglich angegebenen Ziel-DC.

---

## 5. Rücktransport der Antworten vom Backend zum Client

Antwortpakete durchlaufen den inversen Pfad, beginnend im RPC-Handler des Proxys:

```

RPC_PROXY_ANS → Zuordnung via out_conn_id

```

Der Proxy verwendet hierbei eine interne Mapping-Tabelle, welche jede Backend-Verbindung einer konkreten Client-Session zuordnet.

Falls eine gültige Zuordnung existiert:

```

client_send_message(...)

```

überträgt die Antwort unverändert an den ursprünglichen Client.

Falls keine Zuordnung existiert (z. B. weil die Client-Verbindung bereits geschlossen wurde):

```

RPC_CLOSE_CONN

```

wird an das Backend gesendet, um Ressourcen freizugeben und Zombie-Sessions zu vermeiden.

Dies verhindert Desynchronisation zwischen Frontend- und Backend-Zustand.

---

## 6. Konfigurationsseitige Steuerung des Routings für DC 203

Das Routingverhalten wird vollständig durch die Clusterdefinition in der Konfiguration bestimmt.

Beispiel:

```

proxy_for 203 149.154.x.x:443;

```

bewirkt:

- Erstellung eines Clusters mit `cluster_id = 203`
- Zuweisung der angegebenen Backend-Server zu diesem Cluster

Zusätzlich kann definiert werden:

```

default 2;

```

Dies legt den Fallback-Cluster fest, der verwendet wird, wenn keine spezifische DC-Zuordnung existiert.

Ohne explizite `proxy_for 203`-Direktive erfolgt daher automatisch Routing über den Default-Cluster.

---

## 7. Zusammenfassung des effektiven Systemverhaltens

Für eine Client-Verbindung mit gesetztem Ziel-DC 203 gilt deterministisch:

- Die Ziel-DC-ID wird einmalig aus dem initialen Obfuscation-Header extrahiert.
- Dieser Wert wird unverändert in der Verbindungsstruktur gespeichert.
- Sämtlicher Traffic dieser Session wird ausschließlich anhand dieses Wertes geroutet.
- Existiert ein Cluster mit ID 203, wird dieser verwendet.
- Andernfalls erfolgt ein Fallback auf den Default-Cluster.
- Der Inhalt der MTProto-Payload beeinflusst die Routingentscheidung zu keinem Zeitpunkt.
- Der Proxy fungiert ausschließlich als zustandsbehafteter Transport-Forwarder ohne Protokollinterpretation.

Damit ist der Ziel-DC vollständig durch den initialen Transport-Header definiert und bleibt über die gesamte Lebensdauer der Verbindung invariant.
```
